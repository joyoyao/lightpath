'use strict'

const logger = require('./logger')
const consola = require('consola')
const amqp = require('amqplib')
const NodeCache = require('node-cache')
const consul = require('./consul')
const vault = require('./vault')
const db = require('../models')
const { unescape } = require('validator')
const jwt = require('jsonwebtoken')
const crypto = require('crypto')
const axios = require('axios')

module.exports = class Worker {
	constructor({ rabbitmq_url, rabbitmq_queue, consul_host, consul_port, vault_endpoint, vault_version, vault_header = false, cache_ttl = 86400 }) {
		// Set variables
		this.url = rabbitmq_url
		this.queue_name = rabbitmq_queue

		// Start cache
		this.cache = new NodeCache({ stdTTL: cache_ttl })

		// Initiate Consul
		this.consul = new consul({ host: consul_host, port: consul_port })

		// Initiate Vault
		this.vault = new vault({ endpoint: vault_endpoint, version: vault_version, request_header: vault_header })
	}

	// Function to connect to Rabbitmq
	async connect() {
		try {
			logger.info('Executing health checks...')

			// Vault health check
			// if (await this.vault.health()) logger.info('Vault is healthy!')
			// else throw new Error('Vault is not healthy!')

			// Consul health check
			if (await this.consul.health()) consola.success('Consul is healthy!')
			else throw new Error('Consul is not healthy!')

			logger.info('Connecting to RabbitMQ...')

			// Connect to RabbitMQ
			this.connection = await amqp.connect(this.url)

			// On connection error, reconnect to RabbitMQ
			this.connection.on('error', (err) => {
				consola.error('Connection error: ' + err.message)
				setTimeout(() => this.connect(), 1000)
			})

			// On connection close, reconnect to RabbitMQ
			this.connection.on('close', () => {
				consola.error('Connection closed')
				setTimeout(() => this.connect(), 1000)
			})

			consola.success('Connection successful!')

			await this.consume()
		} catch (err) {
			// Reconnect on failure
			consola.error('Connection error: ' + err.message)
			setTimeout(() => this.connect(), 1000)
		}
	}

	// Function listen and consume jobs
	async consume() {
		try {
			// Create channel
			this.channel = await this.connection.createChannel()

			// On channel error, reconnect to RabbitMQ
			this.channel.on('error', (err) => {
				consola.error('Channel error:' + err.message)
				setTimeout(() => this.connect(), 1000)
			})

			// On channel close, reconnect to RabbitMQ
			this.channel.on('close', () => {
				consola.error('Channel closed')
				setTimeout(() => this.connect(), 1000)
			})

			// Create queue
			await this.channel.assertQueue(this.queue_name, { durable: true })

			// Start consuming jobs
			logger.info('Worker started')
			await this.channel.consume(
				this.queue_name,
				async (msg) => {
					try {
						const uuid = msg.content.toString()
						logger.info(`Processing job ${uuid}`)

						// Look up job details
						const job = await db.purges.findOne({
							where: {
								uuid: uuid,
							},
							attributes: ['urls'],
							include: [
								{
									model: db.zones,
									attributes: ['uuid', 'regions'],
								},
							],
						})

						// Job not found
						if (!job) {
							await this.channel.ack(msg)
							return consola.error('Job not found in database')
						}

						// Turn urls into array and unescape
						const urls = job.urls.split(',').map((url) => {
							const parsed = new URL(unescape(url))
							return parsed.pathname + parsed.search
						})

						// Look up datacenters within regions
						const servers = await db.servers.findAll({
							where: {
								region: job.zone.regions,
							},
							attributes: ['uuid', 'consul'],
						})

						// Loop through servers result and call purge function
						await Promise.all(
							servers.map((server) =>
								this.purge({
									uuid: uuid,
									datacenter: server.consul,
									server: server.uuid,
									zoneKey: job.zone.uuid,
									urls: urls,
								})
							)
						)

						// Sent ack that job is finished
						await this.channel.ack(msg)

						consola.success(`Finished job ${uuid}`)
					} catch (err) {
						consola.error('Error occurred while processing job: ' + err.message)
					}
				},
				{ noAck: false }
			)
		} catch (err) {
			// Reconnect on failure
			consola.error('Channel error: ' + err.message)
			setTimeout(() => this.connect(), 1000)
		}
	}

	// Function to purge
	async purge({ uuid, datacenter, server, zoneKey, urls, retries = 3, iterations = 1, delay = 1000 }) {
		const tagged = consola.withScope('newTag')
		tagged.info('test')

		// Get rdns for server
		let rdns = await this.getRdns(datacenter, server)

		// Get secret for server
		let secret = await this.getSecret(server)

		// Generate JWT and key signature
		let auth = await this.generateAuth(secret, server, urls, zoneKey)

		do {
			// Announce retry attempts
			if (iterations > 1) logger.info(`[${server.toUpperCase()}] Executing retry attempt ${iterations}/${retries}`)

			try {
				// Send cache purge request
				const response = await axios({
					method: 'PURGE',
					url: `http://${rdns}:2841`,
					headers: {
						Authorization: auth.token,
						'X-Key-Signature': auth.signature,
						'X-Purge-Request': true,
					},
				})

				return consola.success(`[${server.toUpperCase()}] Cache successfully purged!`)
			} catch (err) {
				// Out of retires, throw error
				if (iterations >= retries) return consola.error(`[${server.toUpperCase()}] Failed to clear cache. ${retries} attempt(s) failed!`)

				// Async timeout
				await new Promise((resolve) => setTimeout(resolve, delay))

				// Actions based on error
				if (err.response && err.response.status === 403) {
					logger.info(`[${server.toUpperCase()}] [${iterations}/${retries}] Received 403 from server. Fetching new secret from Vault`)

					// Get secret for server from Vault directly
					secret = await this.getSecret(server, true)

					// Generate JWT and key signature
					auth = await this.generateAuth(secret, server, urls, zoneKey)
				} else if (err.code === 'ECONNREFUSED') {
					logger.info(`[${server.toUpperCase()}] Connection refused. Fetching new info from Consul`)

					// Get rdns for server from Consul directory
					rdns = await this.getRdns(datacenter, server, true)
				} else logger.info(`[${server.toUpperCase()}] Received error ${err.message}`)
			}

			// Increase iterations
			iterations++
		} while (iterations <= retries)
	}

	async getRdns(datacenter, server, cacheBypass = false) {
		let rdns

		// Query cache for rdns
		if (!cacheBypass) rdns = this.cache.get(`consul/${server}`)

		// Not found in cache
		if (rdns === undefined) {
			// Query Consul for node info
			const consul = await this.consul.getNodes({ service: 'openresty', datacenter: datacenter, tag: server })
			rdns = consul[0].ServiceMeta.rdns

			// Set in cache
			if (!this.cache.set(`consul/${server}`, rdns)) consola.warn(`[${server.toUpperCase()}] Failed to cache Consul response`)
		}

		return rdns
	}

	async getSecret(server, cacheBypass = false) {
		let secret

		// Query cache for secret
		if (!cacheBypass) secret = this.cache.get(`vault/${server}`)

		if (secret === undefined) {
			// Query Vault for secret
			const auth = await this.vault.getSecret(`edge/data/${server}/auth`)
			secret = auth.secret

			// Set in cache
			if (!this.cache.set(`vault/${server}`, secret)) consola.warn(`[${server.toUpperCase()}] Failed to cache Vault response`)
		}

		return secret
	}

	async generateAuth(secret, server, urls, zoneKey) {
		// Generate jwt token
		const token = await jwt.sign({ urls: urls, zone: zoneKey }, secret, {
			algorithm: 'HS256',
			expiresIn: '10m',
			issuer: 'Light Path CDN',
			audience: server,
		})

		// Generate key signature
		const signature = crypto.createHmac('sha256', server).update(secret).digest('hex')

		return { token: token, signature: signature }
	}
}
